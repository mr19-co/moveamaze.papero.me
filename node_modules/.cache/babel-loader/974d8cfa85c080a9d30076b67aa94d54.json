{"remainingRequest":"/home/max/WebstormProjects/moveamaze.papero.me/node_modules/thread-loader/dist/cjs.js!/home/max/WebstormProjects/moveamaze.papero.me/node_modules/babel-loader/lib/index.js!/home/max/WebstormProjects/moveamaze.papero.me/node_modules/eslint-loader/index.js??ref--13-0!/home/max/WebstormProjects/moveamaze.papero.me/src/functions/functions.js","dependencies":[{"path":"/home/max/WebstormProjects/moveamaze.papero.me/src/functions/functions.js","mtime":1621321100125},{"path":"/home/max/WebstormProjects/moveamaze.papero.me/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/max/WebstormProjects/moveamaze.papero.me/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/max/WebstormProjects/moveamaze.papero.me/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/max/WebstormProjects/moveamaze.papero.me/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIjsKaW1wb3J0IHsgbWF6ZURpbWVuc2lvbnMgfSBmcm9tICIuLi9jb25zdGFudHMvY29uc3RhbnRzIjsKLyppbXBvcnQgeyBQcmlvcml0eVF1ZXVlIH0gZnJvbSAiLi9Qcmlvcml0eVF1ZXVlIjsqLwoKaW1wb3J0IF8gZnJvbSAibG9kYXNoIjsKCmZ1bmN0aW9uIG1hemVUb0dyYXBoKHRpbGVHcmlkKSB7CiAgdmFyIHJlc3VsdCA9IHt9OwoKICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChyb3cpIHsKICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoY29sdW1uKSB7CiAgICAgIHZhciBub2RlTmVpZ2hib3JzID0gW107CiAgICAgIHZhciB0aGlzVGlsZSA9IHRpbGVHcmlkW3Jvd11bY29sdW1uXTsKICAgICAgdmFyIHRvcFRpbGUgPSB0cnlFbHNlTnVsbChmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHRpbGVHcmlkW3JvdyAtIDFdW2NvbHVtbl07CiAgICAgIH0pOwogICAgICBpZiAodG9wVGlsZSAmJiB0aGlzVGlsZS5vcGVuaW5nc1swXSAmJiB0b3BUaWxlLm9wZW5pbmdzWzJdKSBub2RlTmVpZ2hib3JzLnB1c2goewogICAgICAgIHJvdzogcm93IC0gMSwKICAgICAgICBjb2x1bW46IGNvbHVtbgogICAgICB9KTsKICAgICAgdmFyIGJvdHRvbVRpbGUgPSB0cnlFbHNlTnVsbChmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHRpbGVHcmlkW3JvdyArIDFdW2NvbHVtbl07CiAgICAgIH0pOwogICAgICBpZiAoYm90dG9tVGlsZSAmJiB0aGlzVGlsZS5vcGVuaW5nc1syXSAmJiBib3R0b21UaWxlLm9wZW5pbmdzWzBdKSBub2RlTmVpZ2hib3JzLnB1c2goewogICAgICAgIHJvdzogcm93ICsgMSwKICAgICAgICBjb2x1bW46IGNvbHVtbgogICAgICB9KTsKICAgICAgdmFyIGxlZnRUaWxlID0gdHJ5RWxzZU51bGwoZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB0aWxlR3JpZFtyb3ddW2NvbHVtbiAtIDFdOwogICAgICB9KTsKICAgICAgaWYgKGxlZnRUaWxlICYmIHRoaXNUaWxlLm9wZW5pbmdzWzNdICYmIGxlZnRUaWxlLm9wZW5pbmdzWzFdKSBub2RlTmVpZ2hib3JzLnB1c2goewogICAgICAgIHJvdzogcm93LAogICAgICAgIGNvbHVtbjogY29sdW1uIC0gMQogICAgICB9KTsKICAgICAgdmFyIHJpZ2h0VGlsZSA9IHRyeUVsc2VOdWxsKGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gdGlsZUdyaWRbcm93XVtjb2x1bW4gKyAxXTsKICAgICAgfSk7CiAgICAgIGlmIChyaWdodFRpbGUgJiYgdGhpc1RpbGUub3BlbmluZ3NbMV0gJiYgcmlnaHRUaWxlLm9wZW5pbmdzWzNdKSBub2RlTmVpZ2hib3JzLnB1c2goewogICAgICAgIHJvdzogcm93LAogICAgICAgIGNvbHVtbjogY29sdW1uICsgMQogICAgICB9KTsKICAgICAgcmVzdWx0W1tyb3csIGNvbHVtbl1dID0gewogICAgICAgIG5laWdoYm9yczogbm9kZU5laWdoYm9ycwogICAgICB9OwogICAgfTsKCiAgICBmb3IgKHZhciBjb2x1bW4gPSAzOyBjb2x1bW4gPD0gbWF6ZURpbWVuc2lvbnMubk9mQ29sdW1ucyArIDI7IGNvbHVtbisrKSB7CiAgICAgIF9sb29wMihjb2x1bW4pOwogICAgfQogIH07CgogIGZvciAodmFyIHJvdyA9IDM7IHJvdyA8PSBtYXplRGltZW5zaW9ucy5uT2ZSb3dzICsgMjsgcm93KyspIHsKICAgIF9sb29wKHJvdyk7CiAgfQoKICByZXR1cm4gcmVzdWx0Owp9Ci8qZXhwb3J0IGZ1bmN0aW9uIGRpamtzdHJhc0Fsb2dvcml0aG0oZ3JhcGgsIHN0YXJ0LCBlbmQpewogICAgY29uc29sZS5sb2coJ2RpamtzdGFcJ3MgYWxnb3JpdGhtJykKCgogICAgZ3JhcGggPSBfLmNsb25lRGVlcChncmFwaCkKCiAgICBjb25zdCBwcmlvcml0eVF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKGEsIGIpID0+IHsgcmV0dXJuIGEuZGlzdGFuY2UgPCBiLmRpc3RhbmNlIH0pCiAgICBmb3IgKGxldCByb3cgPSAzOyByb3cgPD0gbWF6ZURpbWVuc2lvbnMubk9mUm93cyArIDI7IHJvdysrKSB7CiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMzsgY29sdW1uIDw9IG1hemVEaW1lbnNpb25zLm5PZkNvbHVtbnMgKyAyOyBjb2x1bW4rKykgewogICAgICAgICAgICBjb25zdCBub2RlID0gT2JqZWN0LmFzc2lnbigKICAgICAgICAgICAgICAgIGdyYXBoW1sgcm93LCBjb2x1bW4gXV0sCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgcm93LCBjb2x1bW4gfSwKICAgICAgICAgICAgICAgICAgICBwcmV2aW91czogbnVsbCwKICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogcm93ID09PSBzdGFydC5yb3cgJiYgY29sdW1uID09PSBzdGFydC5jb2x1bW4gPyAwIDogMTAwMDAwMAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICApCiAgICAgICAgICAgIHByaW9yaXR5UXVldWUucHVzaChub2RlKQogICAgICAgIH0KICAgIH0KICAgIGNvbnNvbGUubG9nKGdyYXBoKQogICAgY29uc29sZS5sb2cocHJpb3JpdHlRdWV1ZSkKCiAgICBjb25zb2xlLmxvZyhwcmlvcml0eVF1ZXVlLmlzRW1wdHkoKSkKICAgIHdoaWxlICghcHJpb3JpdHlRdWV1ZS5pc0VtcHR5KCkpIHsKICAgICAgICBjb25zdCB0aWxlID0gcHJpb3JpdHlRdWV1ZS5wb3AoKQogICAgICAgIGNvbnNvbGUubG9nKHRpbGUpCiAgICAgICAgbGV0IG5laWdoYm9yCiAgICAgICAgZm9yIChuZWlnaGJvciBpbiB0aWxlLm5laWdoYm9ycykgewogICAgICAgICAgICBpZiAodGlsZS5kaXN0YW5jZSArIDEgPCBncmFwaFtbbmVpZ2hib3Iucm93LCBuZWlnaGJvci5jb2x1bW5dXS5kaXN0YW5jZSkgewogICAgICAgICAgICAgICAgZ3JhcGhbW25laWdoYm9yLnJvdywgbmVpZ2hib3IuY29sdW1uXV0ucHJldmlvdXMgPSB0aWxlLnBvc2l0aW9uCiAgICAgICAgICAgICAgICBncmFwaFtbbmVpZ2hib3Iucm93LCBuZWlnaGJvci5jb2x1bW5dXS5kaXN0YW5jZSA9IHRpbGUuZGlzdGFuY2UgKyAxCiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CgogICAgY29uc3QgcmVzdWx0ID0gW10KICAgIGxldCB0aWxlID0gZW5kCiAgICB3aGlsZSh0aWxlKSB7CiAgICAgICAgcmVzdWx0LnB1c2godGlsZSkKICAgICAgICB0aWxlID0gZ3JhcGhbW3RpbGUucm93LCB0aWxlLmNvbHVtbl1dLnByZXZpb3VzCiAgICB9CgogICAgY29uc29sZS5sb2coZ3JhcGgpCiAgICByZXR1cm4gcmVzdWx0Cn0qLwoKLypmdW5jdGlvbiBkaWprc3RyYUFsb2dvcml0aG0oZ3JhcGgsIHN0YXJ0LCBlbmQsIGFscmVhZHlTZWVuID0gW10pIHsKICAgIF8uY2xvbmVEZWVwKGFscmVhZHlTZWVuKQogICAgY29uc29sZS5sb2coZ3JhcGgpCgogICAgaWYgKHN0YXJ0LnJvdyA9PT0gZW5kLnJvdyAmJiBzdGFydC5jb2x1bW4gPT09IGVuZC5jb2x1bW4pIHsKICAgICAgICBjb25zb2xlLmxvZygnZW5kIHJlYWNoZWQ6ICcgKyBzdGFydC5yb3cgKyAnLCAnICsgc3RhcnQuY29sdW1uKQogICAgICAgIGFscmVhZHlTZWVuLnB1c2goZW5kKQogICAgICAgIHJldHVybiBhbHJlYWR5U2VlbgogICAgfQoKICAgIGNvbnN0IHVuc2Vlbk5laWdoYm9ycyA9IGdyYXBoW1tzdGFydC5yb3csIHN0YXJ0LmNvbHVtbl1dLm5laWdoYm9ycy5maWx0ZXIoKG5laWdoYm9yKSA9PiB7CiAgICAgICAgbGV0IGhhc0JlZW5TZWVuID0gZmFsc2UKICAgICAgICBjb25zb2xlLmxvZygnbmVpZ2hib3I6ICcgKyBuZWlnaGJvci5yb3cgKyAnLScgKyBuZWlnaGJvci5jb2x1bW4pCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHJlYWR5U2Vlbi5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBjb25zdCBhcyA9IGFscmVhZHlTZWVuW2ldCiAgICAgICAgICAgIGlmIChuZWlnaGJvci5yb3cgPT09IGFzLnJvdyAmJiBuZWlnaGJvci5jb2x1bW4gPT09IGFzLmNvbHVtbikgewogICAgICAgICAgICAgICAgaGFzQmVlblNlZW4gPSB0cnVlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc29sZS5sb2coJ2FzOiAnICsgYXMucm93ICsgJy0nICsgYXMuY29sdW1uKQogICAgICAgICAgICBjb25zb2xlLmxvZygnYXM6ICcgKyBhcykKICAgICAgICB9CiAgICAgICAgY29uc29sZS5sb2coJ2hhc0JlZW5TZWVuOiAnICsgaGFzQmVlblNlZW4pCiAgICAgICAgcmV0dXJuICFoYXNCZWVuU2VlbgogICAgfSkKICAgIGNvbnNvbGUubG9nKCd1bnNlZW5OZWlnaGJvcnM6ICcgKyB1bnNlZW5OZWlnaGJvcnMubWFwKCh0aWxlKSA9PiB0aWxlLnJvdyArICctJyArIHRpbGUuY29sdW1uKS5qb2luKCIsICIpKQogICAgaWYgKHVuc2Vlbk5laWdoYm9ycy5sZW5ndGggPT09IDApIHsKICAgICAgICBjb25zb2xlLmxvZygnZGVhZCBlbmQ6ICcgKyBzdGFydC5yb3cgKyAnLCAnICsgc3RhcnQuY29sdW1uKQogICAgICAgIHJldHVybiBudWxsCiAgICB9CgogICAgYWxyZWFkeVNlZW4ucHVzaChzdGFydCkKICAgIGNvbnNvbGUubG9nKCdub2RlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhdGg6ICcgKyBzdGFydC5yb3cgKyAnLCAnICsgc3RhcnQuY29sdW1uKQogICAgbGV0IHNob3J0ZXN0UGF0aCA9IG51bGwKICAgIHVuc2Vlbk5laWdoYm9ycy5mb3JFYWNoKChuZWlnaGJvcikgPT4gewogICAgICAgIGNvbnN0IHNob3J0ZXN0UGF0aFRocm91Z2hOZWlnaGJvciA9IGRpamtzdHJhQWxvZ29yaXRobShncmFwaCwgbmVpZ2hib3IsIGVuZCwgYWxyZWFkeVNlZW4pCiAgICAgICAgaWYgKHNob3J0ZXN0UGF0aFRocm91Z2hOZWlnaGJvcikgewogICAgICAgICAgICBpZiAoc2hvcnRlc3RQYXRoKSB7CiAgICAgICAgICAgICAgICBpZiAoc2hvcnRlc3RQYXRoVGhyb3VnaE5laWdoYm9yLmxlbmd0aCA8IHNob3J0ZXN0UGF0aC5sZW5ndGgpIHsKICAgICAgICAgICAgICAgICAgICBzaG9ydGVzdFBhdGggPSBzaG9ydGVzdFBhdGhUaHJvdWdoTmVpZ2hib3IKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHNob3J0ZXN0UGF0aCA9IHNob3J0ZXN0UGF0aFRocm91Z2hOZWlnaGJvcgogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfSkKCiAgICByZXR1cm4gc2hvcnRlc3RQYXRoCn0qLwoKCmV4cG9ydCBmdW5jdGlvbiBkaWprc3RyYXNBbGdvcml0aG0oZ3JhcGgsIHN0YXJ0LCBlbmQpIHsKICByZXR1cm4gZmluZEFsbFBhdGhzKGdyYXBoLCBzdGFydCwgZW5kLCBbXSkuc29ydChmdW5jdGlvbiAoYSwgYikgewogICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7CiAgfSlbMF07Cn0KCmZ1bmN0aW9uIGZpbmRBbGxQYXRocyhncmFwaCwgc3RhcnQsIGVuZCwgYWxyZWFkeVNlZW4pIHsKICBhbHJlYWR5U2VlbiA9IF8uY2xvbmVEZWVwKGFscmVhZHlTZWVuLm1hcChmdW5jdGlvbiAoYSkgewogICAgcmV0dXJuIGE7CiAgfSkpOwogIGFscmVhZHlTZWVuLnB1c2goc3RhcnQpOwoKICBpZiAob2JqZWN0c0VxdWFsKHN0YXJ0LCBlbmQpKSB7CiAgICByZXR1cm4gW2FscmVhZHlTZWVuXTsKICB9CgogIHZhciB1bnNlZW5OZWlnaGJvcnMgPSByZW1vdmVPYmplY3RzRnJvbUFycmF5KGdyYXBoW1tzdGFydC5yb3csIHN0YXJ0LmNvbHVtbl1dLm5laWdoYm9ycywgYWxyZWFkeVNlZW4pOwoKICBpZiAodW5zZWVuTmVpZ2hib3JzLmxlbmd0aCA9PT0gMCkgewogICAgcmV0dXJuIFtdOwogIH0gZWxzZSB7CiAgICB2YXIgcmVzdWx0ID0gW107CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bnNlZW5OZWlnaGJvcnMubGVuZ3RoOyBpKyspIHsKICAgICAgdmFyIHBhdGhzID0gZmluZEFsbFBhdGhzKGdyYXBoLCB1bnNlZW5OZWlnaGJvcnNbaV0sIGVuZCwgYWxyZWFkeVNlZW4pOwoKICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykgewogICAgICAgIHJlc3VsdC5wdXNoKHBhdGhzW2pdKTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfQp9CgpleHBvcnQgZnVuY3Rpb24gb2JqZWN0c0VxdWFsKG8xLCBvMikgewogIHJldHVybiBvMS5yb3cgPT09IG8yLnJvdyAmJiBvMS5jb2x1bW4gPT09IG8yLmNvbHVtbjsKfQpleHBvcnQgZnVuY3Rpb24gb2JqZWN0SW5BcnJheShvLCBhcnIpIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgewogICAgaWYgKG9iamVjdHNFcXVhbChhcnJbaV0sIG8pKSByZXR1cm4gdHJ1ZTsKICB9CgogIHJldHVybiBmYWxzZTsKfQpleHBvcnQgZnVuY3Rpb24gcmVtb3ZlT2JqZWN0c0Zyb21BcnJheShsMSwgbDIpIHsKICByZXR1cm4gbDEuZmlsdGVyKGZ1bmN0aW9uIChvKSB7CiAgICByZXR1cm4gIW9iamVjdEluQXJyYXkobywgbDIpOwogIH0pOwp9CmV4cG9ydCBmdW5jdGlvbiBuZWlnaGJvclBvc2l0aW9uKHRpbGUxLCB0aWxlMikgewogIGlmICh0aWxlMS5yb3cgLSAxID09PSB0aWxlMi5yb3cgJiYgdGlsZTEuY29sdW1uID09PSB0aWxlMi5jb2x1bW4pIHsKICAgIHJldHVybiAndXAnOwogIH0KCiAgaWYgKHRpbGUxLnJvdyArIDEgPT09IHRpbGUyLnJvdyAmJiB0aWxlMS5jb2x1bW4gPT09IHRpbGUyLmNvbHVtbikgewogICAgcmV0dXJuICdkb3duJzsKICB9CgogIGlmICh0aWxlMS5yb3cgPT09IHRpbGUyLnJvdyAmJiB0aWxlMS5jb2x1bW4gLSAxID09PSB0aWxlMi5jb2x1bW4pIHsKICAgIHJldHVybiAnbGVmdCc7CiAgfQoKICBpZiAodGlsZTEucm93ID09PSB0aWxlMi5yb3cgJiYgdGlsZTEuY29sdW1uICsgMSA9PT0gdGlsZTIuY29sdW1uKSB7CiAgICByZXR1cm4gJ3JpZ2h0JzsKICB9CgogIHJldHVybiAnJzsKfQoKZnVuY3Rpb24gdHJ5RWxzZU51bGwoZnVuKSB7CiAgdHJ5IHsKICAgIHJldHVybiBmdW4oKTsKICB9IGNhdGNoIChfdW51c2VkKSB7CiAgICByZXR1cm4gbnVsbDsKICB9Cn0KCmV4cG9ydCBmdW5jdGlvbiBzbGVlcChtaWxsaXNlY29uZHMpIHsKICB2YXIgZGF0ZSA9IERhdGUubm93KCk7CiAgdmFyIGN1cnJlbnREYXRlID0gbnVsbDsKCiAgZG8gewogICAgY3VycmVudERhdGUgPSBEYXRlLm5vdygpOwogIH0gd2hpbGUgKGN1cnJlbnREYXRlIC0gZGF0ZSA8IG1pbGxpc2Vjb25kcyk7Cn0KZXhwb3J0IHsgbWF6ZVRvR3JhcGgsIHRyeUVsc2VOdWxsIH07"},{"version":3,"sources":["/home/max/WebstormProjects/moveamaze.papero.me/src/functions/functions.js"],"names":["mazeDimensions","_","mazeToGraph","tileGrid","result","row","column","nodeNeighbors","thisTile","topTile","tryElseNull","openings","push","bottomTile","leftTile","rightTile","neighbors","nOfColumns","nOfRows","dijkstrasAlgorithm","graph","start","end","findAllPaths","sort","a","b","length","alreadySeen","cloneDeep","map","objectsEqual","unseenNeighbors","removeObjectsFromArray","i","paths","j","o1","o2","objectInArray","o","arr","l1","l2","filter","neighborPosition","tile1","tile2","fun","sleep","milliseconds","date","Date","now","currentDate"],"mappings":"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","sourcesContent":["import {mazeDimensions} from \"../constants/constants\";\n/*import { PriorityQueue } from \"./PriorityQueue\";*/\nimport _ from \"lodash\"\n\nfunction mazeToGraph(tileGrid){\n    const result = {}\n    for (let row = 3; row <= mazeDimensions.nOfRows + 2; row++) {\n        for (let column = 3; column <= mazeDimensions.nOfColumns + 2; column++) {\n            const nodeNeighbors = []\n            const thisTile = tileGrid[row][column]\n\n            const topTile = tryElseNull(() => tileGrid[row - 1][column])\n            if (topTile && thisTile.openings[0] && topTile.openings[2])\n                nodeNeighbors.push({ row: row - 1, column: column })\n            const bottomTile = tryElseNull(() => tileGrid[row + 1][column])\n            if (bottomTile && thisTile.openings[2] && bottomTile.openings[0])\n                nodeNeighbors.push({ row: row + 1, column: column })\n            const leftTile = tryElseNull(() => tileGrid[row][column - 1])\n            if (leftTile && thisTile.openings[3] && leftTile.openings[1])\n                nodeNeighbors.push({ row: row, column: column - 1 })\n            const rightTile = tryElseNull(() => tileGrid[row][column + 1])\n            if (rightTile && thisTile.openings[1] && rightTile.openings[3])\n                nodeNeighbors.push({ row: row, column: column + 1 })\n\n            result[[row, column]] = { neighbors: nodeNeighbors }\n        }\n    }\n\n    return result\n}\n\n/*export function dijkstrasAlogorithm(graph, start, end){\n    console.log('dijksta\\'s algorithm')\n\n\n    graph = _.cloneDeep(graph)\n\n    const priorityQueue = new PriorityQueue((a, b) => { return a.distance < b.distance })\n    for (let row = 3; row <= mazeDimensions.nOfRows + 2; row++) {\n        for (let column = 3; column <= mazeDimensions.nOfColumns + 2; column++) {\n            const node = Object.assign(\n                graph[[ row, column ]],\n                {\n                    position: { row, column },\n                    previous: null,\n                    distance: row === start.row && column === start.column ? 0 : 1000000\n                }\n            )\n            priorityQueue.push(node)\n        }\n    }\n    console.log(graph)\n    console.log(priorityQueue)\n\n    console.log(priorityQueue.isEmpty())\n    while (!priorityQueue.isEmpty()) {\n        const tile = priorityQueue.pop()\n        console.log(tile)\n        let neighbor\n        for (neighbor in tile.neighbors) {\n            if (tile.distance + 1 < graph[[neighbor.row, neighbor.column]].distance) {\n                graph[[neighbor.row, neighbor.column]].previous = tile.position\n                graph[[neighbor.row, neighbor.column]].distance = tile.distance + 1\n            }\n        }\n    }\n\n    const result = []\n    let tile = end\n    while(tile) {\n        result.push(tile)\n        tile = graph[[tile.row, tile.column]].previous\n    }\n\n    console.log(graph)\n    return result\n}*/\n\n/*function dijkstraAlogorithm(graph, start, end, alreadySeen = []) {\n    _.cloneDeep(alreadySeen)\n    console.log(graph)\n\n    if (start.row === end.row && start.column === end.column) {\n        console.log('end reached: ' + start.row + ', ' + start.column)\n        alreadySeen.push(end)\n        return alreadySeen\n    }\n\n    const unseenNeighbors = graph[[start.row, start.column]].neighbors.filter((neighbor) => {\n        let hasBeenSeen = false\n        console.log('neighbor: ' + neighbor.row + '-' + neighbor.column)\n        for (let i = 0; i < alreadySeen.length; i++) {\n            const as = alreadySeen[i]\n            if (neighbor.row === as.row && neighbor.column === as.column) {\n                hasBeenSeen = true\n            }\n            console.log('as: ' + as.row + '-' + as.column)\n            console.log('as: ' + as)\n        }\n        console.log('hasBeenSeen: ' + hasBeenSeen)\n        return !hasBeenSeen\n    })\n    console.log('unseenNeighbors: ' + unseenNeighbors.map((tile) => tile.row + '-' + tile.column).join(\", \"))\n    if (unseenNeighbors.length === 0) {\n        console.log('dead end: ' + start.row + ', ' + start.column)\n        return null\n    }\n\n    alreadySeen.push(start)\n    console.log('node in the middle of the path: ' + start.row + ', ' + start.column)\n    let shortestPath = null\n    unseenNeighbors.forEach((neighbor) => {\n        const shortestPathThroughNeighbor = dijkstraAlogorithm(graph, neighbor, end, alreadySeen)\n        if (shortestPathThroughNeighbor) {\n            if (shortestPath) {\n                if (shortestPathThroughNeighbor.length < shortestPath.length) {\n                    shortestPath = shortestPathThroughNeighbor\n                }\n            } else {\n                shortestPath = shortestPathThroughNeighbor\n            }\n        }\n    })\n\n    return shortestPath\n}*/\n\nexport function dijkstrasAlgorithm(graph, start, end) {\n    return findAllPaths(graph, start, end, []).sort((a, b) => b.length - a.length)[0]\n}\n\nfunction findAllPaths(graph, start, end, alreadySeen) {\n    alreadySeen = _.cloneDeep(alreadySeen.map((a) => a))\n    alreadySeen.push(start)\n\n    if (objectsEqual(start, end)) {\n        return [alreadySeen]\n    }\n\n    const unseenNeighbors = removeObjectsFromArray(graph[[start.row, start.column]].neighbors, alreadySeen)\n    if(unseenNeighbors.length === 0) {\n        return []\n    } else {\n        const result = []\n        for (let i = 0; i < unseenNeighbors.length; i++) {\n            const paths = findAllPaths(graph, unseenNeighbors[i], end, alreadySeen)\n            for (let j = 0; j < paths.length; j++) {\n                result.push(paths[j])\n            }\n        }\n        return result\n    }\n\n}\n\nexport function objectsEqual(o1, o2) {\n    return o1.row === o2.row && o1.column === o2.column\n}\n\nexport function objectInArray(o, arr) {\n    for (let i = 0; i < arr.length; i++) {\n        if (objectsEqual(arr[i], o))\n            return true\n    }\n    return false\n}\n\nexport function removeObjectsFromArray(l1, l2) {\n    return l1.filter((o) => !objectInArray(o, l2))\n}\n\nexport function neighborPosition(tile1, tile2) {\n    if (tile1.row - 1 === tile2.row && tile1.column === tile2.column) {\n        return 'up'\n    }\n    if (tile1.row + 1 === tile2.row && tile1.column === tile2.column) {\n        return 'down'\n    }\n    if (tile1.row === tile2.row && tile1.column - 1 === tile2.column) {\n        return 'left'\n    }\n    if (tile1.row === tile2.row && tile1.column + 1 === tile2.column) {\n        return 'right'\n    }\n    return ''\n}\n\n\n\nfunction tryElseNull(fun){\n    try {\n        return fun()\n    } catch {\n        return null\n    }\n}\n\nexport function sleep(milliseconds) {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date < milliseconds);\n}\n\nexport {mazeToGraph, tryElseNull}"]}]}